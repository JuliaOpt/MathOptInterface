<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing a solver interface · MathOptInterface</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MathOptInterface</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li><li><a class="tocitem" href="../../background/duality/">Duality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../modification/">Problem modification</a></li><li><a class="tocitem" href="../example/">A complete example: solving a knapsack problem</a></li><li class="is-active"><a class="tocitem" href>Implementing a solver interface</a><ul class="internal"><li><a class="tocitem" href="#Deciding-if-MathOptInterface-is-right-for-you"><span>Deciding if MathOptInterface is right for you</span></a></li><li><a class="tocitem" href="#Find-a-similar-solver-already-wrapped"><span>Find a similar solver already wrapped</span></a></li><li><a class="tocitem" href="#Create-a-low-level-interface"><span>Create a low-level interface</span></a></li><li><a class="tocitem" href="#Structuring-the-package"><span>Structuring the package</span></a></li><li><a class="tocitem" href="#The-Optimizer-object"><span>The <code>Optimizer</code> object</span></a></li><li><a class="tocitem" href="#The-first-big-decision:-incremental-modifications?"><span>The first big decision: incremental modifications?</span></a></li><li><a class="tocitem" href="#Solver-specific-attributes"><span>Solver-specific attributes</span></a></li><li><a class="tocitem" href="#Supported-constrained-variables-and-constraints"><span>Supported constrained variables and constraints</span></a></li><li><a class="tocitem" href="#Handling-duplicate-coefficients"><span>Handling duplicate coefficients</span></a></li><li><a class="tocitem" href="#Implementing-copy"><span>Implementing copy</span></a></li><li><a class="tocitem" href="#JuMP-mapping"><span>JuMP mapping</span></a></li><li><a class="tocitem" href="#Column-Generation"><span>Column Generation</span></a></li><li><a class="tocitem" href="#Problem-data"><span>Problem data</span></a></li><li><a class="tocitem" href="#Statuses"><span>Statuses</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../reference/models/">Models</a></li><li><a class="tocitem" href="../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Implementing a solver interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementing a solver interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/MathOptInterface.jl/blob/master/docs/src/manual/implementing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementing-a-solver-interface"><a class="docs-heading-anchor" href="#Implementing-a-solver-interface">Implementing a solver interface</a><a id="Implementing-a-solver-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-a-solver-interface" title="Permalink"></a></h1><p>This guide outlines the basic steps to implement an interface to  MathOptInterface for a new solver. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Implementing an interface to MathOptInterface for a new solver is a lot of  work. Before starting, we recommend that you join the  <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a> and explain a  little bit about the solver you are wrapping. If you have questions that are not answered by this guide, please ask them in the <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a>.</p></div></div><h2 id="Deciding-if-MathOptInterface-is-right-for-you"><a class="docs-heading-anchor" href="#Deciding-if-MathOptInterface-is-right-for-you">Deciding if MathOptInterface is right for you</a><a id="Deciding-if-MathOptInterface-is-right-for-you-1"></a><a class="docs-heading-anchor-permalink" href="#Deciding-if-MathOptInterface-is-right-for-you" title="Permalink"></a></h2><p>The first step in writing a wrapper is to decide whether implementing an  interface is the right thing to do. </p><p>MathOptInterface is an abstraction layer for unifying <em>constrained</em> mathematical  optimization solvers. If your solver doesn&#39;t fit in the category, i.e., it implements a derivative-free algorithm for unconstrained objective functions,  MathOptInterface may not be the right tool for the job. </p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you&#39;re not sure whether you ssould write an interface, ask in the  <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a>.</p></div></div><h2 id="Find-a-similar-solver-already-wrapped"><a class="docs-heading-anchor" href="#Find-a-similar-solver-already-wrapped">Find a similar solver already wrapped</a><a id="Find-a-similar-solver-already-wrapped-1"></a><a class="docs-heading-anchor-permalink" href="#Find-a-similar-solver-already-wrapped" title="Permalink"></a></h2><p>The next step is to find (if possible) a similar solver that is already wrapped. Although not strictly necessary, this will be a good place to look for  inspiration when implementing your wrapper.</p><p>The <a href="https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers">JuMP documentation</a> has a good list of solvers, along with the problem classes they support. </p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you&#39;re not sure which solver is most similar, ask in the  <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a>.</p></div></div><h2 id="Create-a-low-level-interface"><a class="docs-heading-anchor" href="#Create-a-low-level-interface">Create a low-level interface</a><a id="Create-a-low-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-low-level-interface" title="Permalink"></a></h2><h3 id="Wrapping-solvers-written-in-Julia"><a class="docs-heading-anchor" href="#Wrapping-solvers-written-in-Julia">Wrapping solvers written in Julia</a><a id="Wrapping-solvers-written-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapping-solvers-written-in-Julia" title="Permalink"></a></h3><p>If your solver is written in Julia, there&#39;s nothing to do here! Go to the next  section.</p><h3 id="Solvers-written-in-C"><a class="docs-heading-anchor" href="#Solvers-written-in-C">Solvers written in C</a><a id="Solvers-written-in-C-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-written-in-C" title="Permalink"></a></h3><p>Julia is well suited to wrapping solvers written in C.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is <em>not</em> true for C++.</p></div></div><p>Before writing a MathOptInterface wrapper, there are a few extra steps.</p><h4 id="Create-a-JLL"><a class="docs-heading-anchor" href="#Create-a-JLL">Create a JLL</a><a id="Create-a-JLL-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-JLL" title="Permalink"></a></h4><p>If the C code is publicly available under an open-source license, create a  JLL package via <a href="https://github.com/JuliaPackaging/Yggdrasil">Yggdrasil</a>. The  easiest way to do this is to copy an existing solver. Good examples to follow are the <a href="https://github.com/JuliaPackaging/Yggdrasil/tree/master/C/Coin-OR">COIN-OR solvers</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Building the solver via Yggdrasil is non-trivial. please ask the  <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a> for help.</p></div></div><p>If the code is commercial or not publicly available, the user will need to manually install the solver. See <a href="https://github.com/jump-dev/Gurobi.jl">Gurobi.jl</a> or <a href="https://github.com/jump-dev/CPLEX.jl">CPLEX.jl</a> for examples of how to  structure this.</p><h4 id="Use-Clang.jl-to-wrap-the-C-API"><a class="docs-heading-anchor" href="#Use-Clang.jl-to-wrap-the-C-API">Use Clang.jl to wrap the C API</a><a id="Use-Clang.jl-to-wrap-the-C-API-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Clang.jl-to-wrap-the-C-API" title="Permalink"></a></h4><p>The next step is to use <a href="https://github.com/JuliaInterop/Clang.jl">Clang.jl</a> to  automatically wrap the C API. The easiest way to do this is to follow an  example. Good examples to follow are  <a href="https://github.com/jump-dev/Cbc.jl/blob/master/scripts/clang.jl">Cbc.jl</a> and <a href="https://github.com/jump-dev/HiGHS.jl/blob/master/gen/gen.jl">HiGHS.jl</a>.</p><p>Sometimes, you will need to make manual modifications to the resulting files.</p><h3 id="Solvers-written-in-other-languages"><a class="docs-heading-anchor" href="#Solvers-written-in-other-languages">Solvers written in other languages</a><a id="Solvers-written-in-other-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-written-in-other-languages" title="Permalink"></a></h3><p>Ask the <a href="https://gitter.im/JuliaOpt/JuMP-dev">Developer chatroom</a> for advice. You may be able to use on of the JuliaInterop packages to call out to the  solver.</p><p>For example, <a href="https://github.com/jump-dev/SeDuMi.jl">SeDuMi.jl</a> uses  <a href="https://github.com/JuliaInterop/MATLAB.jl">MATLAB.jl</a> to call the SeDuMi solver written in MATLAB.</p><h2 id="Structuring-the-package"><a class="docs-heading-anchor" href="#Structuring-the-package">Structuring the package</a><a id="Structuring-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Structuring-the-package" title="Permalink"></a></h2><p>Structure your wrapper as a Julia package.</p><p>MOI solver interfaces may be in the same package as the solver itself (either  the C wrapper if the solver is accessible through C, or the Julia code if the  solver is written in Julia, for example). </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The JuMP <a href="https://jump.dev/pages/governance/#core-contributors">core contributors</a> request that you do not use &quot;JuMP&quot; in the name of your package without prior consent.</p></div></div><p>The guideline for naming the file containing the MOI wrapper is  <code>src/MOI_wrapper.jl</code> and <code>test/MOI_wrapper.jl</code> for the tests. </p><p>If the MOI wrapper implementation is spread in several files, they should be  stored in a <code>src/MOI_wrapper</code> folder and included by a  <code>src/MOI_wrapper/MOI_wrapper.jl</code> file.</p><p>For example:</p><pre><code class="language-none">/gen
    gen.jl  # Code to wrap the C API
/src
    NewSolver.jl
    /gen
        libnewsolver_api.jl
        libnewsolver_common.jl
    /MOI_wrapper
        MOI_wrapper.jl
        other_files.jl
/test
    runtests.jl
    /MOI_wrapper
        MOI_wrapper.jl</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For the info on how to structure the tests, see  <a href="../../submodules/Test/overview/#How-to-test-a-solver">How to test a solver</a>.</p></div></div><h2 id="The-Optimizer-object"><a class="docs-heading-anchor" href="#The-Optimizer-object">The <code>Optimizer</code> object</a><a id="The-Optimizer-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-Optimizer-object" title="Permalink"></a></h2><p>The first object to create is a subtype of <code>AbstractOptimizer</code>. By convention,  these optimizers should not be exported and should be named  <code>PackageName.Optimizer</code>.</p><pre><code class="language-julia">struct Optimizer &lt;: MOI.AbstractOptimizer
    # Fields go here
end</code></pre><h3 id="Optimizer-objects-for-C-solvers"><a class="docs-heading-anchor" href="#Optimizer-objects-for-C-solvers">Optimizer objects for C solvers</a><a id="Optimizer-objects-for-C-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-objects-for-C-solvers" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This section is important if you wrap a solver written in C.</p></div></div><p>Wrapping a solver written in C will require the use of pointers. <strong>Never pass  the pointer directly to a low-level function.</strong> Instead, store the pointer as a  field in your <code>Optimizer</code>, and implement <code>Base.cconvert</code> and  <code>Base.unsafe_convert</code>.</p><pre><code class="language-julia">struct Optimizer &lt;: MOI.AbstractOptimizer
    ptr::Ptr{Cvoid}
end

Base.cconvert(::Type{Ptr{Cvoid}}, model::Optimizer) = model
Base.unsafe_convert(::Type{Ptr{Cvoid}}, model::Optimizer) = model.ptr</code></pre><p>Then, pass <code>model</code> instead of <code>model.ptr</code> to low-level functions that expect the model pointer.</p><h3 id="Implement-methods-for-Optimizer"><a class="docs-heading-anchor" href="#Implement-methods-for-Optimizer">Implement methods for <code>Optimizer</code></a><a id="Implement-methods-for-Optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-methods-for-Optimizer" title="Permalink"></a></h3><p>Now that we have an <code>Optimizer</code>, we need to implement a few basic methods.</p><ul><li><code>Base.show(::IO, ::Optimizer)</code>    Overload <code>show</code> to print a nice string when some prints your model.</li><li><a href="../../reference/models/#MathOptInterface.empty!"><code>empty!</code></a> and <a href="../../reference/models/#MathOptInterface.is_empty"><code>is_empty</code></a></li></ul><h3 id="Implement-Optimizer-attributes"><a class="docs-heading-anchor" href="#Implement-Optimizer-attributes">Implement Optimizer attributes</a><a id="Implement-Optimizer-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-Optimizer-attributes" title="Permalink"></a></h3><ul><li><a href="../../reference/models/#MathOptInterface.SolverName"><code>SolverName</code></a></li><li><a href="../../reference/models/#MathOptInterface.Name"><code>Name</code></a></li><li><a href="../../reference/models/#MathOptInterface.Silent"><code>Silent</code></a></li><li><a href="../../reference/models/#MathOptInterface.TimeLimitSec"><code>TimeLimitSec</code></a></li><li><a href="../../reference/models/#MathOptInterface.RawParameter"><code>RawParameter</code></a></li></ul><h2 id="The-first-big-decision:-incremental-modifications?"><a class="docs-heading-anchor" href="#The-first-big-decision:-incremental-modifications?">The first big decision: incremental modifications?</a><a id="The-first-big-decision:-incremental-modifications?-1"></a><a class="docs-heading-anchor-permalink" href="#The-first-big-decision:-incremental-modifications?" title="Permalink"></a></h2><p>The first big decision you face is whether to support incremental modification.</p><p>Incremental modification means that you can add variables and constraints  one-by-one without needing to rebuild the entire problem, and you can modify  the problem data after an <a href="../../reference/models/#MathOptInterface.optimize!"><code>optimize!</code></a> call. Supporting incremental  modification means implementing functions like <a href="../../reference/variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and  <a href="../../reference/constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a>.</p><p>The alternative is to accept the problem data in a single <a href="../../reference/models/#MathOptInterface.copy_to"><code>copy_to</code></a>  function call, afterwhich it cannot be modified.</p><p>Good examples of solvers supporting incremental modification are MILP solvers like <a href="https://github.com/jump-dev/GLPK.jl">GLPK.jl</a> and  <a href="https://github.com/jump-dev/Gurobi.jl">Gurobi.jl</a>. Examples of <a href="../../reference/models/#MathOptInterface.copy_to"><code>copy_to</code></a> solvers are <a href="https://github.com/jump-dev/AmplNLWriter.jl">AmplNLWriter.jl</a> and <a href="https://github.com/jump-dev/SCS.jl">SCS.jl</a></p><p>It is possible to implement both approaches, but you should probably start with one for simplicity.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Only support incremental modification if your solver has native support for  it.</p></div></div><p>In general, supporting incremental modification is more work, and it usually  some extra book-keeping. However, it provides a more efficient interface to the  solver, particularly if the problem is going to be resolved multiple times with small modifications. </p><p>Moreover, once you&#39;ve implemented incremental modification, it&#39;s usually not  much extra work to add a <a href="../../reference/models/#MathOptInterface.copy_to"><code>copy_to</code></a> interface. The converse is not true.</p><h2 id="Solver-specific-attributes"><a class="docs-heading-anchor" href="#Solver-specific-attributes">Solver-specific attributes</a><a id="Solver-specific-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-specific-attributes" title="Permalink"></a></h2><p>Solver-specific attributes should be specified by creating an <a href="../../reference/models/#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>. For example, inside <code>MyPackage</code>, we could add the following:</p><pre><code class="language-julia">struct PrintLevel &lt;: MOI.AbstractOptimizerAttribute end
function MOI.set(model::Optimizer, ::PrintLevel, level::Int)
    # ... set the print level ...
end</code></pre><p>Then, the user can write:</p><pre><code class="language-julia">model = MyPackage.Optimizer()
MOI.set(model, MyPackage.PrintLevel(), 0)</code></pre><h2 id="Supported-constrained-variables-and-constraints"><a class="docs-heading-anchor" href="#Supported-constrained-variables-and-constraints">Supported constrained variables and constraints</a><a id="Supported-constrained-variables-and-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-constrained-variables-and-constraints" title="Permalink"></a></h2><p>The solver interface should only implement support for variables constrained on creation (see <a href="../../reference/variables/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a>/<a href="../../reference/variables/#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>) or constraints that directly map to a structure exploited by the solver algorithm. There is no need to add support for additional types, this is handled by <a href="../../submodules/Bridges/overview/#The-Bridges-submodule">The Bridges submodule</a>. Furthermore, this allows <a href="../../reference/constraints/#MathOptInterface.supports_constraint"><code>supports_constraint</code></a> to indicate which types are exploited by the solver and hence allows layers such as <a href="../../submodules/Bridges/reference/#MathOptInterface.Bridges.LazyBridgeOptimizer"><code>Bridges.LazyBridgeOptimizer</code></a> to accurately select the most appropriate transformations.</p><p>As <a href="../../reference/variables/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> (resp. <a href="../../reference/variables/#MathOptInterface.add_constrained_variables"><code>add_constrained_variables</code></a>) falls back to <a href="../../reference/variables/#MathOptInterface.add_variable"><code>add_variable</code></a> (resp. <a href="../../reference/variables/#MathOptInterface.add_variables"><code>add_variables</code></a>) followed by <a href="../../reference/constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a>, there is no need to implement this function if <code>model</code> does not require that variables be constrained when they are created. However, if <code>model</code> requires that variables be constrained when they&#39;re created, then it should only implement <a href="../../reference/variables/#MathOptInterface.add_constrained_variable"><code>add_constrained_variable</code></a> and not <a href="../../reference/variables/#MathOptInterface.add_variable"><code>add_variable</code></a> nor <a href="../../reference/constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> for <a href="../../reference/standard_form/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a>-in-<code>typeof(set)</code>. In addition, it should implement <code>supports_add_constrained_variables(::Optimizer, ::Type{Reals})</code> and return <code>false</code> so that these variables are bridged, see <a href="../../reference/variables/#MathOptInterface.supports_add_constrained_variables"><code>supports_add_constrained_variables</code></a>.</p><h2 id="Handling-duplicate-coefficients"><a class="docs-heading-anchor" href="#Handling-duplicate-coefficients">Handling duplicate coefficients</a><a id="Handling-duplicate-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-duplicate-coefficients" title="Permalink"></a></h2><p>Solvers should expect that functions such as <code>ScalarAffineFunction</code> and <code>VectorQuadraticFunction</code> may contain duplicate coefficents, for example, <code>ScalarAffineFunction([ScalarAffineTerm(x, 1), ScalarAffineTerm(x, 1)], 0.0)</code>. These duplicate terms can be aggregated by calling <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.canonical"><code>Utilities.canonical</code></a>.</p><pre><code class="language-julia">x = MathOptInterface.VariableIndex(1)
term = MathOptInterface.ScalarAffineTerm(1, x)
func = MathOptInterface.ScalarAffineFunction([term, term], 0)
func_canon = MathOptInterface.Utilities.canonical(func)
func_canon ≈ MathOptInterface.ScalarAffineFunction(
    [MathOptInterface.ScalarAffineTerm(2, x)], 0)

# output

true</code></pre><h2 id="Implementing-copy"><a class="docs-heading-anchor" href="#Implementing-copy">Implementing copy</a><a id="Implementing-copy-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-copy" title="Permalink"></a></h2><p>Avoid storing extra copies of the problem when possible. This means that solver wrappers should not use <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a> as part of the wrapper. Instead, do one of the following to load the problem (assuming the solver wrapper type is called <code>Optimizer</code>):</p><ul><li><p>If the solver supports loading the problem incrementally, implement <a href="../../reference/variables/#MathOptInterface.add_variable"><code>add_variable</code></a>, <a href="../../reference/constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> for supported constraints and <a href="../../reference/models/#MathOptInterface.set"><code>set</code></a> for supported attributes and add:</p><pre><code class="language-julia">function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>with</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::Optimizer, copy_names::Bool) = true</code></pre><p>or</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::Optimizer, copy_names::Bool) = !copy_names</code></pre><p>depending on whether the solver support names; see <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a> for more details.</p></li><li><p>If the solver does not support loading the problem incrementally, do not implement <a href="../../reference/variables/#MathOptInterface.add_variable"><code>add_variable</code></a> and <a href="../../reference/constraints/#MathOptInterface.add_constraint"><code>add_constraint</code></a> as implementing them would require caching the problem. Let users or JuMP decide whether to use a <code>CachingOptimizer</code> instead. Write either a custom implementation of <a href="../../reference/models/#MathOptInterface.copy_to"><code>copy_to</code></a> or implement the <a href="../../submodules/Utilities/overview/#Allocate-Load-API">Allocate-Load API</a>. If you choose to implement the Allocate-Load API, do</p><pre><code class="language-julia">function MOI.copy_to(dest::Optimizer, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>with</p><pre><code class="language-julia">MOI.Utilities.supports_allocate_load(model::Optimizer, copy_names::Bool) = true</code></pre><p>or</p><pre><code class="language-julia">MOI.Utilities.supports_allocate_load(model::Optimizer, copy_names::Bool) = !copy_names</code></pre><p>depending on whether the solver support names; see <a href="../../submodules/Utilities/reference/#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> for more details.</p><p>Note that even if both writing a custom implementation of <a href="../../reference/models/#MathOptInterface.copy_to"><code>copy_to</code></a> and implementing the <a href="../../submodules/Utilities/overview/#Allocate-Load-API">Allocate-Load API</a> requires the user to copy the model from a cache, the <a href="../../submodules/Utilities/overview/#Allocate-Load-API">Allocate-Load API</a> allows MOI layers to be added between the cache and the solver which allows transformations to be applied without the need for additional caching. For instance, with the proposed <a href="https://github.com/jump-dev/MathOptInterface.jl/issues/523">Light bridges</a>, no cache will be needed to store the bridged model when bridges are used by JuMP so implementing the <a href="../../submodules/Utilities/overview/#Allocate-Load-API">Allocate-Load API</a> will allow JuMP to use only one cache instead of two.</p></li></ul><h2 id="JuMP-mapping"><a class="docs-heading-anchor" href="#JuMP-mapping">JuMP mapping</a><a id="JuMP-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP-mapping" title="Permalink"></a></h2><p>MOI defines a very general interface, with multiple possible ways to describe the same constraint.</p><p>This is considered a feature, not a bug.</p><p>MOI is designed to make it possible to experiment with alternative representations of an optimization problem at both the solving and modeling level.</p><p>When implementing an interface, it is important to keep in mind that the way the user can express problems in JuMP is not directly limited by the constraints which a solver supports via MOI as JuMP performs automatic reformulation via <a href="../../submodules/Bridges/overview/#The-Bridges-submodule">The Bridges submodule</a>.</p><p>Therefore, we recommend to only support the constraint types that directly map to a structure exploited by the solver algorithm.</p><p>The following bullet points show examples of how JuMP constraints are translated into MOI function-set pairs:</p><ul><li><code>@constraint(m, 2x + y &lt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>LessThan</code></li><li><code>@constraint(m, 2x + y &gt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>GreaterThan</code></li><li><code>@constraint(m, 2x + y == 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>EqualTo</code></li><li><code>@constraint(m, 0 &lt;= 2x + y &lt;= 10)</code> becomes <code>ScalarAffineFunction</code>-in-<code>Interval</code></li><li><code>@constraint(m, 2x + y in ArbitrarySet())</code> becomes <code>ScalarAffineFunction</code>-in-<code>ArbitrarySet</code>.</li></ul><p>Variable bounds are handled in a similar fashion:</p><ul><li><code>@variable(m, x &lt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>LessThan</code></li><li><code>@variable(m, x &gt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>GreaterThan</code></li></ul><p>One notable difference is that a variable with an upper and lower bound is translated into two constraints, rather than an interval. i.e.:</p><ul><li><code>@variable(m, 0 &lt;= x &lt;= 1)</code> becomes <code>SingleVariable</code>-in-<code>LessThan</code> <em>and</em>  <code>SingleVariable</code>-in-<code>GreaterThan</code>.</li></ul><p>Solvers are not expected to support <code>AbstractScalarFunction</code> in <code>GreaterThan</code>, <code>LessThan</code>, <code>EqualTo</code>, or <code>Interval</code> with a nonzero constant in the function. Constants in the affine function should instead be moved into the parameters of the corresponding sets. The <a href="../../reference/errors/#MathOptInterface.ScalarFunctionConstantNotZero"><code>ScalarFunctionConstantNotZero</code></a> exception may be thrown in this case.</p><h2 id="Column-Generation"><a class="docs-heading-anchor" href="#Column-Generation">Column Generation</a><a id="Column-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Column-Generation" title="Permalink"></a></h2><p>There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver&#39;s API once all of the new coefficients are known.</p><h2 id="Problem-data"><a class="docs-heading-anchor" href="#Problem-data">Problem data</a><a id="Problem-data-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-data" title="Permalink"></a></h2><p>All data passed to the solver should be copied immediately to internal data structures. Solvers may not modify any input vectors and should assume that input vectors may be modified by users in the future. This applies, for example, to the <code>terms</code> vector in <code>ScalarAffineFunction</code>. Vectors returned to the user, e.g., via <code>ObjectiveFunction</code> or <code>ConstraintFunction</code> attributes, should not be modified by the solver afterwards. The in-place version of <code>get!</code> can be used by users to avoid extra copies in this case.</p><h2 id="Statuses"><a class="docs-heading-anchor" href="#Statuses">Statuses</a><a id="Statuses-1"></a><a class="docs-heading-anchor-permalink" href="#Statuses" title="Permalink"></a></h2><p>Solver wrappers should document how the low-level statuses map to the MOI statuses. Statuses like <code>NEARLY_FEASIBLE_POINT</code> and <code>INFEASIBLE_POINT</code>, are designed to be used when the solver explicitly indicates that relaxed tolerances are satisfied or the returned point is infeasible, respectively.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« A complete example: solving a knapsack problem</a><a class="docs-footer-nextpage" href="../../reference/standard_form/">Standard form »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 19 April 2021 05:37">Monday 19 April 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
